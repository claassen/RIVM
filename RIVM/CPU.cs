using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using VirtualMachine.Instructions;

namespace VirtualMachine
{
    [Flags]
    public enum CompareFlag
    {
        LT = 1,
        EQ = 2,
        GT = 3,
        LE = LT | EQ,
        GE = GT | EQ
    }

    public static class SystemMemoryMap
    {
        public static readonly int BIOS_ROM_START = 0;
        public static readonly int BIOS_ROM_END = 1023;
        public static readonly int IO_PORT_START = 1024;
        public static readonly int IO_PORT_END = 2047;
        public static readonly int RAM_START = 2048;
    }

    public class CPU
    {
        public Registers Registers;
        public MemoryController Memory;
        public CompareFlag Flag;
        public bool KernelMode;
        public bool Halted;
        
        public CPU(MemoryController memory)
        {
            Registers = new Registers();
            Memory = memory;
        }

        public void Start()
        {
            KernelMode = true;
            Memory.PageTableEnabled = false;
            
            while (true)
            {
                try
                {
                    if (!Halted)
                    {
                        int machineCode = Fetch();
                        var instruction = InstructionDecoder.Decode(machineCode);

                        if (instruction.HasImmediate)
                        {
                            instruction.Immediate = Fetch();
                        }

                        instruction.Execute(this);
                    }
                    else
                    {
                        Thread.Sleep(100);
                    }

                    //TODO: 
                    //Poll for externally generated hardware interrupts which will be generated by hooking up the VM
                    //to keyboard input, maybe some kind of disk device (to replace the current simplistic implementation) etc.
                }
                catch (HardwareInterruptException ex)
                {
                    Halted = false;

                    //index into Interrupt Descriptor Table
                    int interrupt = (int)ex.Interrupt;

                    //Switch to kernel mode and set IP to interrupt handler address
                    KernelMode = true;
                    
                    //Context switch? (software) (kernel stack?) (IP* - need to set to either next instruction or re-execute the same instruction)

                    Registers[Register.IP] = Memory[Registers[Register.IDT] + interrupt];
                }
            }
        }

        private int Fetch()
        {
            return Memory[Registers[Register.IP]++];

            //byte[] bytes = new byte[4];

            //for (int i = 0; i < 4; i++)
            //{
            //    bytes[i] = Memory[Registers[Register.IP]++];
            //}

            //return BitConverter.ToInt32(bytes.Reverse().ToArray(), 0);
        }
    }
}
